/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201601121427.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: Software Over The Air Client API
 */
#ifndef V1_ORG_GENIVI_SOTA_CLIENT_HPP_
#define V1_ORG_GENIVI_SOTA_CLIENT_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace org {
namespace genivi {

class SotaClient {
public:
    virtual ~SotaClient() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct SWMResult : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SWM_RES_OK = 0,
            SWM_RES_ALREADY_PROCESSED = 1,
            SWM_RES_DEPENDENCY_FAILURE = 2,
            SWM_RES_VALIDATION_FAILED = 3,
            SWM_RES_INSTALL_FAILED = 4,
            SWM_RES_UPGRADE_FAILED = 5,
            SWM_RES_REMOVAL_FAILED = 6,
            SWM_RES_FLASH_FAILED = 7,
            SWM_RES_CREATE_PARTITION_FAILED = 8,
            SWM_RES_DELETE_PARTITION_FAILED = 9,
            SWM_RES_RESIZE_PARTITION_FAILED = 10,
            SWM_RES_WRITE_PARTITION_FAILED = 11,
            SWM_RES_PATCH_PARTITION_FAILED = 12,
            SWM_RES_USER_DECLINED = 13,
            SWM_RES_SOFTWARE_BLACKLISTED = 14,
            SWM_RES_DISK_FULL = 15,
            SWM_RES_NOT_FOUND = 16,
            SWM_RES_OLD_VERSION = 17,
            SWM_RES_INTERNAL_ERROR = 18,
            SWM_RES_GENERAL_ERROR = 19
        };
        
        SWMResult() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SWM_RES_OK)) {}
        SWMResult(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SWM_RES_OK):
                case static_cast<int32_t>(Literal::SWM_RES_ALREADY_PROCESSED):
                case static_cast<int32_t>(Literal::SWM_RES_DEPENDENCY_FAILURE):
                case static_cast<int32_t>(Literal::SWM_RES_VALIDATION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_INSTALL_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_UPGRADE_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_REMOVAL_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_FLASH_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_CREATE_PARTITION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_DELETE_PARTITION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_RESIZE_PARTITION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_WRITE_PARTITION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_PATCH_PARTITION_FAILED):
                case static_cast<int32_t>(Literal::SWM_RES_USER_DECLINED):
                case static_cast<int32_t>(Literal::SWM_RES_SOFTWARE_BLACKLISTED):
                case static_cast<int32_t>(Literal::SWM_RES_DISK_FULL):
                case static_cast<int32_t>(Literal::SWM_RES_NOT_FOUND):
                case static_cast<int32_t>(Literal::SWM_RES_OLD_VERSION):
                case static_cast<int32_t>(Literal::SWM_RES_INTERNAL_ERROR):
                case static_cast<int32_t>(Literal::SWM_RES_GENERAL_ERROR):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SWMResult &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SWMResult &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SWMResult &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SWMResult &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SWMResult &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SWMResult &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: A single result of a software operation, included in an 
    	updateReport().
     */
    struct OperationResult : CommonAPI::Struct<std::string, SWMResult, std::string> {
    	
    	OperationResult() {
    	}
    	OperationResult(const std::string &_id, const SWMResult &_resultCode, const std::string &_resultText)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _resultCode;
    		std::get<2>(values_) = _resultText;
    	}
    	/**
    	 * description: The operation id, as specified by the manifest's 
    			operstions.id field.
    	 */
    	inline const std::string &getId() const { return std::get<0>(values_); }
    	inline void setId(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The result code reported by PackMgr, PartMgr, or ML
    			for the given operation.
    	 */
    	inline const SWMResult &getResultCode() const { return std::get<1>(values_); }
    	inline void setResultCode(const SWMResult &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: A descriptive result text reported by PackMgr, PartMgr, or ML
    			for the given
    	 *   operation.
    	 */
    	inline const std::string &getResultText() const { return std::get<2>(values_); }
    	inline void setResultText(const std::string &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const OperationResult& _other) const {
                return (getId() == _other.getId() && getResultCode() == _other.getResultCode() && getResultText() == _other.getResultText());
        }
    	inline bool operator!=(const OperationResult &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct UpdateAvailable : CommonAPI::Struct<std::string, std::string, std::string, bool, uint64_t, std::string> {
    	
    	UpdateAvailable() {
    		std::get<3>(values_) = false;
    	}
    	UpdateAvailable(const std::string &_update_id, const std::string &_description, const std::string &_signature, const bool &_request_confirmation, const uint64_t &_size, const std::string &_name)
    	{
    		std::get<0>(values_) = _update_id;
    		std::get<1>(values_) = _description;
    		std::get<2>(values_) = _signature;
    		std::get<3>(values_) = _request_confirmation;
    		std::get<4>(values_) = _size;
    		std::get<5>(values_) = _name;
    	}
    	/**
    	 * description: Package ID of update. Not currently used.
    	 */
    	inline const std::string &getUpdate_id() const { return std::get<0>(values_); }
    	inline void setUpdate_id(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: A descriptive text of the available update.
    	 */
    	inline const std::string &getDescription() const { return std::get<1>(values_); }
    	inline void setDescription(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Signature generated of the digest of updateId, for example:
    			echo $UPDATE_ID |
    	 *   openssl dgst -sha256 -sign private_key | base64
    	 */
    	inline const std::string &getSignature() const { return std::get<2>(values_); }
    	inline void setSignature(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Flag to indicate if a user confirmation of the package is
    	        required.
    	 */
    	inline const bool &getRequest_confirmation() const { return std::get<3>(values_); }
    	inline void setRequest_confirmation(const bool _value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The size of the available update, in bytes.
    	 */
    	inline const uint64_t &getSize() const { return std::get<4>(values_); }
    	inline void setSize(const uint64_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: A symbolic name of the available update.
    	 */
    	inline const std::string &getName() const { return std::get<5>(values_); }
    	inline void setName(const std::string &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const UpdateAvailable& _other) const {
                return (getUpdate_id() == _other.getUpdate_id() && getDescription() == _other.getDescription() && getSignature() == _other.getSignature() && getRequest_confirmation() == _other.getRequest_confirmation() && getSize() == _other.getSize() && getName() == _other.getName());
        }
    	inline bool operator!=(const UpdateAvailable &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct DownloadComplete : CommonAPI::Struct<std::string, std::string, std::string> {
    	
    	DownloadComplete() {
    	}
    	DownloadComplete(const std::string &_update_id, const std::string &_update_image, const std::string &_signature)
    	{
    		std::get<0>(values_) = _update_id;
    		std::get<1>(values_) = _update_image;
    		std::get<2>(values_) = _signature;
    	}
    	inline const std::string &getUpdate_id() const { return std::get<0>(values_); }
    	inline void setUpdate_id(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Path on the local file system to the squashfs image
    			containing the update
    	 */
    	inline const std::string &getUpdate_image() const { return std::get<1>(values_); }
    	inline void setUpdate_image(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Signature generated of the digest of the image pointed to
    	        by
    	 *   updateImage, for example: 
    			openssl dgst -sha256 -sign priv_key.pem
    	 *   $updateImage | base64
    	 */
    	inline const std::string &getSignature() const { return std::get<2>(values_); }
    	inline void setSignature(const std::string &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const DownloadComplete& _other) const {
                return (getUpdate_id() == _other.getUpdate_id() && getUpdate_image() == _other.getUpdate_image() && getSignature() == _other.getSignature());
        }
    	inline bool operator!=(const DownloadComplete &_other) const {
    		return !((*this) == _other);
    	}
    
    };
};

const char* SotaClient::getInterface() {
    return ("org.genivi.SotaClient");
}

CommonAPI::Version SotaClient::getInterfaceVersion() {
    return CommonAPI::Version(1, 0);
}

/**
 * description: Error codes returned as a result of an operation.
 */
/**
 * description: A single result of a software operation, included in an 
	updateReport().
 */

} // namespace genivi
} // namespace org
} // namespace v1

namespace CommonAPI {
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_ORG_GENIVI_SOTA_CLIENT_HPP_
